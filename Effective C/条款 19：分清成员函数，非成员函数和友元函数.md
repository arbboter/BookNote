# 条款 19: 分清成员函数，非成员函数和友元函数

## 0. 总则

成员函数和非成员函数最大的区别在于成员函数可以是虚拟的而非成员函
数不行。所以，如果有个函数必须进行动态绑定（见条款 38），就要采用虚拟
函数，而虚拟函数必定是某个类的成员函数。

## 乘法交换律操作符示例

比如类对象要支持有理数乘法，实现了成员函数重载操作符`*`，比如`const A operator*(const A& a) const`，上述可以实现我们自定义对象有理数乘法了，但是有理数是可以和基本类型的整形相乘的，这样对于理数对象`a`，表达式`a*2`是应该合法的，又因为乘法满足交换律，所以表达式`2*a`也应该是合法的。所以...这样一个有理数类就不仅仅是考虑重载实现一个操作符`*`就可以做到的事情了。

### 成员函数版-`实现乘法，但不满足交换律，隐式转换`

```cpp
class A
{
public:
    A(int fz=0, int fm=1)
    {
        cout << "Call Me\n";
        this->fz = fz;
        this->fm = fm;
    }
    const A operator*(const A& a) const
    {
        return A(this->fz * a.fz, this->fm * a.fm);
    }

private:
    int fz;
    int fm;
};
int main()
{
    A a;
    // 隐式转换2为A对象,如果构造函数前使用关键字explicit声明修饰
    // 则会不允许该操作，编译报错
    a*2; // 返回的是A类型,可以使用sizeof(a*2)验证

    // 整个程序执行完共执行构造函数三次
    return 0;
}
```

如果需要的话，编译器会对每个函数的每个参数执行这种隐式类型转换。但它只对函数参数表中列出的参数进行转换，决不会对成员函数所在的对象（即，成员函数中的*this 指针所对应的对象）进行转换。

### 非成员函数版-`实现对象的乘法，满足要求`

```cpp
class A
{
public:
    A(int fz=0, int fm=1)
    {
        this->fz = fz;
        this->fm = fm;
    }

    int z() const
    {
        return fz;
    }

    int m() const
    {
        return fm;
    }

private:
    int fz;     // 分子
    int fm;     // 分母
};

// 非成员函数实现
const A operator*(const A& a, const A& b)
{
    int fz = a.z() * b.z();
    int fm = a.m() * b.m();
    return A(fz, fm);
}
```

此时以满足要求，基本类型传入会使用隐式转换成对象A。

因此遇到不确定使用成员函数非成员函数时，需要都试试，发现自己所需要的，一般这种不确定是基于对使用方法的不明确的。从上述例子我们大概可以总结出，如果要执行的操作对象都在该类型内部，不涉及隐式转换，则优先考虑成员函数。