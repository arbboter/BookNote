# 条款 15: 让 operator=返回*this 的引用

## 0. 总则

标准库中=操作符的返回值是可以修改的且修改了原对象的值，即标准操作符=返回值为对象引用，为了保证自定义的数据类型和标准兼容性，有必要使得我们自定义的类也按照这个标准实现。如：

```cpp
int a=1, b=2, c=3;  // 语句1
(a = b) = c = 5;    // 语句2
```

程序执行结果：a=5,b=2,c=5。其过程为c=5，返回结果为c的引用；然后b赋值给a，此时a=2且小括号返回值为a的引用，然后c的引用赋值给a的引用，使得a=c=5。

因此，在实现自定义类型时需要兼容遵循标准，保证对象允许标准的`链式赋值`，否则就会导致不能连续赋值，或导致调用时的隐式类型转换不能进行。

## 1. 本章测试

没啥特别的例子，讲点其他的吧：按值传参的参数值为什么不能在函数内修改？

因为在函数调用时，会类似有一个函数调用参数赋值给形参的过程，此时编译器会产生临时值对象形参，即实参值赋值给形参，该形参由编译器产生，伺候函数内部使用的实际上是形参对象，故对形参对象值得修改不会影响到调用实参，但如果是引用引用传参的话，因为是引用或指针，则会影响函数调用实参。

如定义函数：

```cpp
void A(T t);
```

函数传参时编译器产生的临时值，如调用`A(a)`则编译器类似地产生临时值`T t = a`，这样函数内部使用的就是编译器临时产生的值，如此函数内部修改的仅是编译器产生的值t，而非入参调用值a了。