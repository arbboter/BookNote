# 条款 3：尽量用 new 和 delete 而不用 malloc 和 free

## 0. 总则

相比于c语言，`new`和`delete`是c++语言新增支持的内存管理方式，是为了新增以支持面向对象的特性，除了具备`malloc`和`free`内存分配释放的功能外，还具备自动调用构造和析构函数以创建及销毁对象的功能。因此在C++代码中，除特殊情况外，一般建议使用`new`和`delete`。

## 1. new/delete和malloc/free

相比于c语言，其中new/delete仅为c++支持，因为new类操作和malloc类操作的机制不一样(new类操作会调用对象的构造析构函数)，故一般情况下new类操作和mallc类操作不允许混用。且不管是new类操作还是malloc类操作，原则上要成对出现，遵循谁创建谁删除的原则。

## 2. 一般的new对象步骤，如new A()

1. 分配空间：调用操作符new在堆上分配一块内存(operator new)
2. 在指定空间上执行构造函数：在1中分配的内存上执行对象的构造函数初始化(placement new)
3. 返回分配的堆地址

## 3. c++中new的一般用法

* 常规的创建对象操作，如 new A()，此时创建失败会抛出bad_alloc异常，故此时判断返回值为空无意义
* 不抛异常的创建对象操作，new(std::nothrow) A()，此时创建失败会返回NULL值
* 在指定内存上创建对象，new(p) A()，其中p为已经分配的足够大的内存，此时仅仅相当于在内存p上执行对象的构造函数，因此不会出现创建内存失败

```cpp
// 在指定内存上创建对象，需要手工调用析构函数，不能用delete
char* p = new char[1024];
A* pa = new(p)A();
pa->Show();
pa->~A();
```

* new操作符重载，重写内存空间分配步骤

## 4. POD数据类型

C++11中对POD的定义：当class/struct是极简的(trivial)、属于标准布局(standard - layout)，
以及他的所有非静态(non - static)成员都是POD时，会被视为POD。
通俗地讲，一个数据类型的对象能通过二进制拷贝后还能保持其对象数据不变，那么它就是一个POD类型。
此外，POD数据类型满足了`平凡的定义`和`标准布局`

### 平凡的定义

1. 有平凡的构造函数
2. 有平凡的拷贝构造函数
3. 有平凡的移动构造函数
4. 有平凡的拷贝赋值运算符
5. 有平凡的移动赋值运算符
6. 有平凡的析构函数
7. 不能包含虚函数
8. 不能包含虚基类

### 标准布局的定义

1. 所有非静态成员有相同的访问权限
2. 继承树中最多只能有一个类有非静态数据成员
3. 子类的第一个非静态成员不可以是基类类型
4. 没有虚函数
5. 没有虚基类
6. 所有非静态成员都符合标准布局类型

## 5. 思考

### 思考1：`new`和`new[]`的区别

对于POD数据类型而言，`new`和`new[]`都是malloc对象所需大小的内存，其内存管理机制相同；对于非POD数据类型，new会根据对象大小malloc对象所需大小的内存并返回所分配空间的起始地址，但是`new[]`会分配4+所需大小的空间大小，且最终返回是分配起始地址+4，而不是所分配空间的起始地址。

### 思考2：`delete`和`delete[]`区别

`delete`适用对象是单个对象，`delete[]`适用对象是数组变量，因为`new[]`会比`new`多分配四个字节存放数组大小，所以在释放对应的内存空间时存在差异，`delete`会尝试使用销毁一个对象的方法，而`delete[]`会尝试使用销毁对象数组的方法，二者互不兼容，胡乱使用会造成不可预知的结果，因此使用`delete`还是`delete[]`一般需要遵循与分配对象时的`new`和`new[]`配对原则。虽然，内置变量类型`delete`和`delete[]`效果一致，但还是建议遵循上述原则。

### 思考3：`new`创建对象时加`()`与不加有啥区别

对于非POD类型而言，二者无区别；对于POD类型，用`new ()`创建对象时会额外自动为POD数据对象置0赋值，且该过程是递归的。

### 思考4：POD数据类型的优点

* 字节赋值, 代码中我们可以安全的使用memset和memcpy函数对POD类型进行初始化和拷贝等操作.
* 提供了对C内存布局的兼容.C++程序可以与C函数 进行相互的操作, 因为POD类型的数据在C++与C之间的操作总是安全的.
* 保证了静态初始化的安全有效, 静态初始化在很多时候能够提高程序的性能, 而POD类型的对象初始化往往更加简单(比如放在目标文件的.bss段, 在初始化中直接被赋0).