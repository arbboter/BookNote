# 条款 7：预先准备好内存不够的情况

## 0. 总则

暂空

## 1. 自定义`new`的出错函数

> 当内存分配请求不能满足时，调用你预先指定的一个出错处理函数。这个方法基于一个常规，即当 `operator new`不能满足请求时，会在抛出异常之前调用客户指定的一个出错处理函数——一般称为`new-handler`函数。

在C++中，指定出错处理函数时要用到`set_new_handler`函数，它在头文件`<new>`里大致是象下面这样定义的：

```cpp
typedef void (*new_handler)();
new_handler set_new_handler(new_handler p) throw();
```

经测试，该函数是在`operator new`失败时，但在抛出异常之前调用的，且如果设置了自定义的函数，就不会再抛出异常了。

```cpp
#include <iostream>
#include <new>

bool    bRun = true;
char*   pReserve = NULL;
void MyNewHandle()
{
    std::cout << "Hello，World." << std::endl;
    bRun = false;
    
    // 释放预留空间
    delete[] pReserve;
    pReserve = NULL;
}
int main()
{
    std::set_new_handler(MyNewHandle);
    try
    {
        pReserve = new char[1024 * 1024 * 100];
        while (bRun)
        {
            new long(1);
        }
        std::cout << "没有异常异常，正常结束" << std::endl;
    }
    catch (std::bad_alloc& e)
    {
        std::cout << "bad_alloc异常:" << e.what() << std::endl;
    }

    return 0;
}
```

上述例子输出结果为:

> Hello，World.  
> 没有异常异常，正常结束

并没有扑捉到异常，且上述示例中预分配的内存是为了在内存分配失败时，释放该内存使得下次`new`可以有更多的可选空间。此外，如果没有该预分配的空间并在失败时释放，那么此次调用失败的new并不会结束，实际上会在调用函数`MyNewHandle`后继续执行`new`，而不会执行下一个`while`判断，为了验证该情况可以尝试将释放预留空间的代码注释掉再运行看看，注意打断点方法。

自定义`new`的出错函数一般要实现的功能:

* 产生更多的内存，如释放预分配的内存。
* 安装另一个错误处理函数。
* 卸除 new-handler，置空后会继续抛出异常。
* 抛出std::bad_alloc。
* 没有返回，程序报错或退出。

